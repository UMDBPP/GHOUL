#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "../IIRFirstOrder.h"
#include "PID.h"

/* Controller parameters */
#define PID_KP 0
#define PID_KI -1
#define PID_KD 0

#define PID_TAU 2

#define PID_LIM_MIN 0
#define PID_LIM_MAX 30

#define PID_LIM_MIN_INT 0
#define PID_LIM_MAX_INT 30

#define SAMPLE_TIME_S 5 // sample time in seconds

/* Maximum run-time of simulation in seconds */
#define SIMULATION_TIME_MAX (5 * 60 * 60)

#define INITIAL_ASCENT_RATE 6500

/* Simulated dynamical system (first order) */
int TestSystem_Update(int inp, int t);

int ascent_changes[] = {-35, -12, -22};
IIRFirstOrder iir;

int ascent_rate = INITIAL_ASCENT_RATE;
int pos = 0;

int main() {

  PIDController pid = {PID_KP,          PID_KI,          PID_KD,
                       PID_TAU,         PID_LIM_MIN,     PID_LIM_MAX,
                       PID_LIM_MIN_INT, PID_LIM_MAX_INT, SAMPLE_TIME_S};
  int setpoint = 23000 * 1000;
  unsigned int delay = 0;

  srand(time(NULL)); // set random seed

  PIDController_Init(&pid);
  IIRFirstOrder_Init(&iir, 990);

  // force initial ascent rate
  for (int i = 0; i < 100; i++)
    IIRFirstOrder_Update(&iir, INITIAL_ASCENT_RATE);

  FILE *f = fopen("pid_output.csv", "w");
  if (f == NULL) {
    printf("Error opening file!\n");
    exit(1);
  }

  fprintf(f, "Time (s),Altitude,Controller Output,Ascent Rate (m/s),Filtered "
             "Ascent Rate (m/s)\n");
  for (int t = 0; t <= SIMULATION_TIME_MAX; t++) {

    /* Get measurement from system */
    int raw_measurement = TestSystem_Update(pid.out, t);
    int filtered_ascent_rate = IIRFirstOrder_Update(&iir, ascent_rate);
    // int measurement = IIRFirstOrder_Update(&iir, raw_measurement);

    pid.out = 0;

    // only start iterating after 30 seconds
    if (t > 30) {
      if (delay <= 0) {
        /* Compute new control signal using filtered measurement*/
        PIDController_Update(&pid, setpoint, raw_measurement);

        // if ascent rate is within desired ranges or time is past some point,
        // do not vent
        if (filtered_ascent_rate < 1400) // || t > 7200
          pid.out = 0;

        /*
if (pos < setpoint + (5000 * 1000) && pos > setpoint - (5000 * 1000)) {
pid.out = 0;
}
        */

        // delay next controller update by the vent time and some additional
        // delay
        delay = pid.out + (2 * 30);
      }
      delay--;
    }

    fprintf(f, "%d,%d,%d,%d,%d\n", t, raw_measurement, pid.out, ascent_rate,
            filtered_ascent_rate);

    if (raw_measurement < 0) {
      printf("Altitude less than 0 meters\n");
      fclose(f);
      return 0;
    }

    if (raw_measurement > 35000 * 1000) {
      printf("Altitude limit reached\n");
      fclose(f);
      return 0;
    }
  }

  fclose(f);

  return 0;
}

int TestSystem_Update(int inp, int t) {

  int32_t delta = ascent_changes[rand() % ((sizeof(ascent_changes) / 4))];
  static int venting = 0;
  static int inner_ascent_rate = INITIAL_ASCENT_RATE;
  // static const int alpha = 2;

  // output = (SAMPLE_TIME_S * inp + output) / (alpha * SAMPLE_TIME_S);

  // simulate venting of helium
  venting = venting + inp;

  if (venting > 0) {
    inner_ascent_rate = inner_ascent_rate + delta;
    venting--;
  }

  double a = ((rand() % 2001) - 1000);
  double b = ((double)((rand() % 1001))) / 1000.0;
  double y = a * sin(b * t);

  int noise = (int)(y);

  // add randomness (updrafts and downdrafts) // + ((rand() % 51) - 25)
  inner_ascent_rate = inner_ascent_rate + ((rand() % 11) - 5);
  ascent_rate = inner_ascent_rate + noise;

  pos = pos + ascent_rate;

  return pos;
}
